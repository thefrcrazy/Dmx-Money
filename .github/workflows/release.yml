name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # CrÃ©er ou mettre Ã  jour la release pour s'assurer qu'elle n'est pas en draft
          gh release create ${{ github.ref_name }} \
            --title "DmxMoney ${{ github.ref_name }}" \
            --notes "Voir le [CHANGELOG](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) pour les dÃ©tails." \
            --draft=false \
            --prerelease=false || gh release edit ${{ github.ref_name }} --draft=false --prerelease=false

  build-and-upload:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'aarch64'
            os_name: 'darwin'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'x64'
            os_name: 'darwin'
          - platform: 'windows-latest'
            args: ''
            arch: 'x64'
            os_name: 'windows'
          - platform: 'ubuntu-22.04'
            args: ''
            arch: 'x64'
            os_name: 'linux'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libjavascriptcoregtk-4.1-dev zip

      - name: Install Frontend dependencies
        run: bun install

      - name: Switch to Modern Mode
        run: |
          chmod +x ./switch-tailwind.sh
          ./switch-tailwind.sh modern
        shell: bash

      # Build sans release automatique mais avec les clÃ©s pour gÃ©nÃ©rer les bundles d'update
      - name: Build Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          includeUpdaterJson: false
          args: ${{ matrix.args }}

      # Gestion manuelle des assets et signature
      - name: Process and Upload Assets
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SIGNING_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          SIGNING_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          ARCH: ${{ matrix.arch }}
          OS_NAME: ${{ matrix.os_name }}
          VERSION: ${{ github.ref_name }} # e.g. v0.1.7
        run: |
          echo "ðŸ” Finding assets..."
          
          CLEAN_VERSION="${VERSION#v}"
          
          # 1. Localiser le rÃ©pertoire bundle (peut Ãªtre dans target/release/bundle ou target/x86_64.../release/bundle)
          BUNDLE_DIR=$(find src-tauri/target -type d -name "bundle" | head -n 1)
          
          if [ -z "$BUNDLE_DIR" ]; then
            echo "âŒ Bundle directory not found anywhere in src-tauri/target!"
            find src-tauri/target -maxdepth 3
            exit 1
          fi
          echo "ðŸ“‚ Bundle directory found: $BUNDLE_DIR"
          
          # 2. Chercher un bundle d'update existant
          UPDATE_BUNDLE=$(find "$BUNDLE_DIR" -type f \( -name "*.app.tar.gz" -o -name "*.AppImage.tar.gz" -o -name "*.nsis.zip" -o -name "*.msi.zip" \) | head -n 1)
          
          # Fallback: chercher n'importe quel zip/tar.gz
          if [ -z "$UPDATE_BUNDLE" ]; then
             UPDATE_BUNDLE=$(find "$BUNDLE_DIR" -type f \( -name "*.tar.gz" -o -name "*.zip" \) | head -n 1)
          fi

          # 3. Fallback CRITIQUE: CrÃ©er le bundle si absent (ex: Windows qui n'a que .exe)
          if [ -z "$UPDATE_BUNDLE" ]; then
            echo "âš ï¸ No update bundle found. Creating one from installer..."
            
            # Chercher un installeur principal
            INSTALLER=$(find "$BUNDLE_DIR" -type f \( -name "*.exe" -o -name "*.msi" -o -name "*.AppImage" -o -name "*.dmg" \) | head -n 1)
            
            if [ -z "$INSTALLER" ]; then
                echo "âŒ No installer found to create bundle from!"
                ls -R "$BUNDLE_DIR"
                exit 1
            fi
            
            echo "ðŸ“¦ Found installer: $INSTALLER"
            INST_FILENAME=$(basename "$INSTALLER")
            
            if [[ "$OS_NAME" == "windows" ]]; then
                # Windows: CrÃ©er un zip
                NEW_ZIP="${INSTALLER}.zip"
                echo "ðŸ—œï¸ Zipping $INSTALLER to $NEW_ZIP"
                if command -v 7z >/dev/null; then
                    7z a "$NEW_ZIP" "$INSTALLER"
                else
                    # PowerShell fallback
                    powershell -Command "Compress-Archive -Path '$INSTALLER' -DestinationPath '$NEW_ZIP'"
                fi
                UPDATE_BUNDLE="$NEW_ZIP"
            else
                # Unix: CrÃ©er un tar.gz
                NEW_TAR="${INSTALLER}.tar.gz"
                echo "ðŸ—œï¸ Compressing $INSTALLER to $NEW_TAR"
                tar -czf "$NEW_TAR" -C "$(dirname "$INSTALLER")" "$INST_FILENAME"
                UPDATE_BUNDLE="$NEW_TAR"
            fi
          fi

          echo "ðŸ“¦ Final update bundle: $UPDATE_BUNDLE"
          
          # 4. PrÃ©parer le nom final standardisÃ©
          FILENAME=$(basename "$UPDATE_BUNDLE")
          if [[ "$FILENAME" == *.app.tar.gz ]]; then EXT="app.tar.gz"
          elif [[ "$FILENAME" == *.AppImage.tar.gz ]]; then EXT="AppImage.tar.gz"
          elif [[ "$FILENAME" == *.nsis.zip ]]; then EXT="nsis.zip"
          elif [[ "$FILENAME" == *.msi.zip ]]; then EXT="msi.zip"
          elif [[ "$FILENAME" == *.tar.gz ]]; then EXT="tar.gz"
          elif [[ "$FILENAME" == *.zip ]]; then EXT="zip"
          else EXT="${FILENAME##*.}"
          fi
          
          NEW_BUNDLE_NAME="DmxMoney_${CLEAN_VERSION}_${ARCH}_${OS_NAME}.${EXT}"
          
          echo "ðŸ”„ Renaming bundle to $NEW_BUNDLE_NAME"
          cp "$UPDATE_BUNDLE" "./$NEW_BUNDLE_NAME"
          
          # 5. Signature
          echo "âœï¸ Signing $NEW_BUNDLE_NAME..."
          export TAURI_SIGNING_PRIVATE_KEY="$SIGNING_KEY"
          export TAURI_SIGNING_PRIVATE_KEY_PASSWORD="$SIGNING_KEY_PASSWORD"
          bun tauri signer sign "./$NEW_BUNDLE_NAME"
          
          SIG_FILE="./$NEW_BUNDLE_NAME.sig"
          if [ ! -f "$SIG_FILE" ]; then
             echo "âŒ Signature creation failed"
             exit 1
          fi
          
          # 6. Upload
          echo "ðŸš€ Uploading bundle and signature..."
          gh release upload "$VERSION" "./$NEW_BUNDLE_NAME" "$SIG_FILE" --clobber
          
          # 7. Upload Installeurs (renommÃ©s)
          echo "ðŸ” Searching for installers to upload..."
          find "$BUNDLE_DIR" -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.msi" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" \) ! -path "*/deps/*" | while read -r INSTALLER_PATH; do
            INST_NAME=$(basename "$INSTALLER_PATH")
            # Nom unique
            NEW_INST_NAME="${INST_NAME%.*}_${ARCH}_${OS_NAME}.${INST_NAME##*.}"
            cp "$INSTALLER_PATH" "./$NEW_INST_NAME"
            echo "ðŸš€ Uploading installer: $NEW_INST_NAME"
            gh release upload "$VERSION" "./$NEW_INST_NAME" --clobber
          done

  generate-updater-json:
    needs: build-and-upload
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Generate multi-platform latest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ github.ref_name }}"
          CLEAN_VERSION="${VERSION#v}"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/$REPO/releases/download/$VERSION"

          echo "ðŸ“¦ Fetching release assets for $VERSION..."
          ASSETS=$(gh release view "$VERSION" --repo "$REPO" --json assets -q '.assets[].name')

          PLATFORMS="{}"

          add_platform() {
            local platform_key="$1"
            local pattern="$2"

            # On cherche le fichier correspondant au pattern (plus flexible)
            ASSET_NAME=$(echo "$ASSETS" | grep -iE "$pattern" | grep -v '\.sig$' | head -n 1)
            
            if [ -n "$ASSET_NAME" ]; then
              SIG_NAME="${ASSET_NAME}.sig"
              if echo "$ASSETS" | grep -qF "$SIG_NAME"; then
                echo "âœ… $platform_key : $ASSET_NAME"
                gh release download "$VERSION" --repo "$REPO" -p "$SIG_NAME" -D /tmp --clobber
                SIGNATURE=$(cat "/tmp/$SIG_NAME")
                
                PLATFORMS=$(echo "$PLATFORMS" | jq \
                  --arg key "$platform_key" \
                  --arg sig "$SIGNATURE" \
                  --arg url "$BASE_URL/$ASSET_NAME" \
                  '. + {($key): {"signature": $sig, "url": $url}}')
              else
                echo "âš ï¸ Missing signature for $ASSET_NAME"
              fi
            else
              echo "â„¹ï¸ No asset match for $platform_key"
            fi
          }

          # Patterns assouplis
          add_platform "darwin-aarch64" "aarch64.*darwin.*app\.tar\.gz"
          add_platform "darwin-x86_64"  "x64.*darwin.*app\.tar\.gz"
          add_platform "windows-x86_64" "x64.*windows.*(msi|nsis)\.zip"
          add_platform "linux-x86_64"   "x64.*linux.*AppImage.*tar\.gz"

          jq -n \
            --arg version "$CLEAN_VERSION" \
            --arg notes "Mise Ã  jour vers la version $CLEAN_VERSION" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}' > latest.json

          echo "ðŸ“„ latest.json content:"
          cat latest.json

          echo "ðŸš€ Uploading latest.json..."
          gh release upload "$VERSION" latest.json --repo "$REPO" --clobber
