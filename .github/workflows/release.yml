name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  publish-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest' # Apple Silicon (M1/M2/M3)
            args: '--target aarch64-apple-darwin'
          - platform: 'macos-latest' # Intel Mac (Cross-compiled from ARM runner)
            args: '--target x86_64-apple-darwin'
          - platform: 'windows-latest' # Windows x64
            args: ''
          - platform: 'ubuntu-22.04'   # Linux x64
            args: ''

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install Linux dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libjavascriptcoregtk-4.1-dev

      - name: Install Frontend dependencies
        run: bun install

      # Force Modern Mode
      - name: Switch to Modern Mode
        run: |
          chmod +x ./switch-tailwind.sh
          ./switch-tailwind.sh modern
        shell: bash

      - name: Build and Publish
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'DmxMoney ${{ github.ref_name }}'
          includeUpdaterJson: false
          releaseBody: |
            ## DmxMoney ${{ github.ref_name }}

            Voir le [CHANGELOG](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) pour les dÃ©tails.
          releaseDraft: false
          prerelease: false
          args: ${{ matrix.args }}

      # Signature manuelle de l'update bundle pour chaque plateforme
      - name: Sign Update Bundle
        if: success()
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SIGNING_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          SIGNING_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "ğŸ” Searching for update bundle..."
          ASSET_FILE=$(find . \( -name "*.app.tar.gz" -o -name "*.nsis.zip" -o -name "*.msi.zip" -o -name "*.AppImage.tar.gz" \) ! -path "*/target/release/deps/*" | head -n 1)

          if [ -z "$ASSET_FILE" ]; then
            echo "âš ï¸ No update asset found. Skipping."
            exit 0
          fi

          echo "âœ… Found: $ASSET_FILE"

          echo "ğŸ”“ Decoding private key..."
          # Debug: check length
          echo "Key length: ${#SIGNING_KEY}"
          
          # Decode base64 to temporary file in /tmp to avoid dashes in path
          # macOS paths in GitHub Actions often cause issues with CLI parsers
          echo "$SIGNING_KEY" | base64 -d > /tmp/signer.key
          
          # Debug: inspect file content
          echo "File size: $(wc -c < /tmp/signer.key | xargs)"
          
          SIG_FILE="$ASSET_FILE.sig"
          echo "âœï¸ Signing $ASSET_FILE..."

          # Use environment variables which is more robust than command line flags
          export TAURI_SIGNING_PRIVATE_KEY="/tmp/signer.key"
          export TAURI_SIGNING_PRIVATE_KEY_PASSWORD="$SIGNING_KEY_PASSWORD"
          
          # Run signer
          bun tauri signer sign "$ASSET_FILE"

          if [ -f "$SIG_FILE" ]; then
            echo "âœ… Signature generated."
            gh release upload ${{ github.ref_name }} "$SIG_FILE" --clobber
            rm ./signer.key
          else
            echo "âŒ Signature failed."
            # Debug: show if file was empty or corrupted
            ls -l ./signer.key
            rm -f ./signer.key
            exit 1
          fi

  # Job d'agrÃ©gation : collecte les signatures de toutes les plateformes
  # et gÃ©nÃ¨re un latest.json multi-plateforme pour l'updater
  generate-updater-json:
    needs: publish-tauri
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Generate multi-platform latest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ github.ref_name }}"
          CLEAN_VERSION="${VERSION#v}"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/$REPO/releases/download/$VERSION"

          echo "ğŸ“¦ Fetching release assets for $VERSION..."
          ASSETS=$(gh release view "$VERSION" --repo "$REPO" --json assets -q '.assets[].name')

          # Initialisation du JSON des plateformes
          PLATFORMS="{}"

          # Fonction : trouver l'asset + sa signature et ajouter au JSON
          add_platform() {
            local platform_key="$1"
            local pattern="$2"

            ASSET_NAME=$(echo "$ASSETS" | grep -E "$pattern" | grep -v '\.sig$' | head -n 1)
            if [ -n "$ASSET_NAME" ]; then
              SIG_NAME="${ASSET_NAME}.sig"
              if echo "$ASSETS" | grep -qF "$SIG_NAME"; then
                echo "âœ… $platform_key : $ASSET_NAME"
                gh release download "$VERSION" --repo "$REPO" -p "$SIG_NAME" -D /tmp --clobber
                SIGNATURE=$(cat "/tmp/$SIG_NAME")
                PLATFORMS=$(echo "$PLATFORMS" | jq \
                  --arg key "$platform_key" \
                  --arg sig "$SIGNATURE" \
                  --arg url "$BASE_URL/$ASSET_NAME" \
                  '. + {($key): {"signature": $sig, "url": $url}}')
              else
                echo "âš ï¸ Pas de signature trouvÃ©e pour $ASSET_NAME"
              fi
            else
              echo "â„¹ï¸ Aucun asset trouvÃ© pour $platform_key"
            fi
          }

          # DÃ©tection de chaque plateforme
          add_platform "darwin-aarch64" "aarch64.*\.app\.tar\.gz$"
          add_platform "darwin-x86_64"  "x86_64.*\.app\.tar\.gz$"
          add_platform "windows-x86_64" "\.(nsis|msi)\.zip$"
          add_platform "linux-x86_64"   "\.AppImage\.tar\.gz$"

          # Construction du latest.json final
          jq -n \
            --arg version "$CLEAN_VERSION" \
            --arg notes "Mise Ã  jour vers la version $CLEAN_VERSION" \
            --arg pub_date "$PUB_DATE" \
            --argjson platforms "$PLATFORMS" \
            '{version: $version, notes: $notes, pub_date: $pub_date, platforms: $platforms}' > latest.json

          echo ""
          echo "ğŸ“„ latest.json gÃ©nÃ©rÃ© :"
          cat latest.json

          echo ""
          echo "ğŸš€ Upload de latest.json..."
          gh release upload "$VERSION" --repo "$REPO" latest.json --clobber
          echo "âœ… TerminÃ© !"